\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[
top=2cm,
bottom=2cm,
left=3cm,
right=2cm,
headheight=17pt, % as per the warning by fancyhdr
includehead,includefoot,
heightrounded, % to avoid spurious underfull messages
]{geometry} 
\geometry{a4paper}
\usepackage[ngerman]{babel}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{siunitx}
\usepackage{graphicx}
\usepackage{caption}
\usepackage[table]{xcolor}
\usepackage{diagbox}
\usepackage{lipsum}

% Assembler
\lstdefinelanguage
{Assembler} % based on the "x86masm" dialect
% with these extra keywords:
{morekeywords={call, mov}} % etc.

% Lecture Name, exercise number, group number/members
\newcommand{\lecture}{Parallel Computer Architecture}
\newcommand{\exercise}{Exercise 5}
\newcommand{\groupnumber}{Group 04}
\newcommand{\groupmembersshort}{Barley, Barth, Nisblé}
\newcommand{\groupmemberslist}{Barley, Daniel\\Barth, Alexander\\Nisblé, Patrick}
\newcommand{\duedate}{2019-12-10, 14:00}

\fancyhf{}
\fancyhead[L]{\groupnumber}
\fancyhead[R]{\textsc{\groupmembersshort}}
\fancyfoot[C]{\lecture: \exercise}
\fancyfoot[R] {\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\pagestyle{fancy}

\begin{document}
	\begin{titlepage}
		\centering
		
		{\scshape\LARGE Universität Heidelberg\\Institute for Computer Engineering (ZITI) \par}
		\vspace{1.5cm}
		{\scshape\Large Master of Science Computer Engineering \par}
		\vspace{0.5cm}
		{\scshape\Large \lecture \par}
		\vspace{1.5cm}
		{\huge\bfseries \exercise \par}
		\vspace{2cm}
		{\Large \groupnumber \itshape  \\ \groupmemberslist \par}
		\vfill
		
		
		% Bottom of the page
		{\large Due date \duedate \par}
	\end{titlepage}

\setcounter{section}{5}
\subsection{Matrix-Multiplikation revisited}

\subsubsection{Parallele Implementierung mittels PThreads}

@todo: code

\subsubsection{Experimente und Evaluation}

\noindent \textbf{a.}

\begin{table}[ht]
	\centering
	\caption[Ausführungszeit $t_{compute}$ (\si{\second})]{Ausführungszeit $t_{compute}$ (\si{\second})}
	\begin{tabular}{c|l|l|l|l|l}
		\hline
		\cellcolor{gray!40}\textbf{\diagbox{Threads}{n}} & \multicolumn{1}{c}{\cellcolor{gray!40}\textbf{2}} & \multicolumn{1}{c}{\cellcolor{gray!40}\textbf{3}} & \multicolumn{1}{c}{\cellcolor{gray!40}\textbf{4}} &
		\multicolumn{1}{c}{\cellcolor{gray!40}\textbf{5}} &
		\multicolumn{1}{c}{\cellcolor{gray!40}\textbf{6}} \\
		\hline\hline
		1 &  &  & & & \\\hline
		2 &  &  & & & \\\hline
		4 &  &  & & & \\\hline
		8 &  &  & & & \\\hline
		16 &  &  & & & \\\hline
		32 &  &  & & & \\\hline
	\end{tabular}
	\label{tab:tcomp}
\end{table}

\begin{table}[ht]
	\centering
	\caption[Ausführungszeit $t_{wall}$ (\si{\second})]{Ausführungszeit $t_{wall}$ (\si{\second})}
	\begin{tabular}{c|l|l|l|l|l}
		\hline
		\cellcolor{gray!40}\textbf{\diagbox{Threads}{n}} & \multicolumn{1}{c}{\cellcolor{gray!40}\textbf{2}} & \multicolumn{1}{c}{\cellcolor{gray!40}\textbf{3}} & \multicolumn{1}{c}{\cellcolor{gray!40}\textbf{4}} &
		\multicolumn{1}{c}{\cellcolor{gray!40}\textbf{5}} &
		\multicolumn{1}{c}{\cellcolor{gray!40}\textbf{6}} \\
		\hline\hline
		1 &  &  & & & \\\hline
		2 &  &  & & & \\\hline
		4 &  &  & & & \\\hline
		8 &  &  & & & \\\hline
		16 &  &  & & & \\\hline
		32 &  &  & & & \\\hline
	\end{tabular}
	\label{tab:twall}
\end{table}

\noindent \textbf{b.}

@todo: complete

\subsection{Vektorrechner - Memory Interleaving}

\noindent \textbf{a.}

Der Vektorrechner benötigt eine dreimal so hohe Speicherbandbreite wie der Durchsatz des Prozessors.
Dies begründet sich durch die Eigenschaft des Vektorrechners, dass in jedem Takt beide Operanden einer Operation geholt, und das Ergebnis zurückgeschrieben wird.
Realisiert wird das durch Memory Interleaving.
Memory Interleaving bezeichnet die Unterteilung eines Speichers in Module gleicher Größe, die Speicherbänke.
Sie sind voneinander unabhängig und können zeitlich verschränkt gelesen oder beschrieben werden.
Daraus resultiert der geforderte höhere Speicherdurchfluss.

\noindent \textbf{b.}

Memory Interleaving haben für skalare Werte und kleine Vektoren keinen Mehrwert.
Abhilfe bieten Vektorregister.
Sie dienen als schnelle Zwischenspeicher, können aufgrund ihrer Größe jedoch nur Teilobjekte aufnehmen.
Vektorregister sind nicht verschränkt.
Aus diesem Grund kann der Zugriff mit beliebiger Adressfolge erfolgen, ohne die effektive Zugriffsbandbreite zu verringern.

\end{document}